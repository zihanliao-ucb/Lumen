#version 430

layout(local_size_x = 64) in;

layout(std430, binding = 0) buffer sdfSizeArray{ int sdfSize[]; };
layout(std430, binding = 1) buffer sdfCoordArray{ float sdfCoord[]; };
layout(std430, binding = 2) buffer sdfArray{ float sdf[]; };
layout(std430, binding = 3) buffer objCardArray{ int objCard[]; };
layout(std430, binding = 4) buffer cardSizeArray{ int cardSize[]; };
layout(std430, binding = 5) buffer cardCoordArray{ float cardCoord[]; };
layout(std430, binding = 6) buffer cardSurfaceArray{ float cardSurface[]; };
layout(std430, binding = 7) buffer cardPointArray{ float cardPoint[]; };
layout(std430, binding = 8) buffer cardRadianceArray{ float cardRadiance[]; };

uniform int uNumSurfacePoints;
uniform int uNumObjects;
uniform int seed;
uniform int uNumSample;

const int maxSteps = 128;
const float epsilon = 0.005;
const float maxMarchDist = 10.0;
const float PI = 3.14159265359;


float sampleAt(ivec3 coord, ivec3 size, int sdfBias, float bv) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, size)))
        return bv;
    int index = sdfBias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    return sdf[index];
}

float sampleSDF(vec3 p_sdf, ivec3 size, int sdfBias) {
    ivec3 base = ivec3(floor(p_sdf));
    if (any(lessThan(base, ivec3(0))) || any(greaterThanEqual(base, size)))
        return maxMarchDist;

    vec3 offset = p_sdf - (vec3(base) + vec3(0.5));
    int dx = int(sign(offset.x));
    int dy = int(sign(offset.y));
    int dz = int(sign(offset.z));
    offset = abs(offset);

    ivec3 c000 = base;
    ivec3 c100 = base + ivec3(dx, 0, 0);
    ivec3 c010 = base + ivec3(0, dy, 0);
    ivec3 c110 = base + ivec3(dx, dy, 0);
    ivec3 c001 = base + ivec3(0, 0, dz);
    ivec3 c101 = base + ivec3(dx, 0, dz);
    ivec3 c011 = base + ivec3(0, dy, dz);
    ivec3 c111 = base + ivec3(dx, dy, dz);

    float v000 = sampleAt(c000, size, sdfBias, 0.0);
    float v100 = sampleAt(c100, size, sdfBias, v000);
    float v010 = sampleAt(c010, size, sdfBias, v000);
    float v110 = sampleAt(c110, size, sdfBias, v000);
    float v001 = sampleAt(c001, size, sdfBias, v000);
    float v101 = sampleAt(c101, size, sdfBias, v000);
    float v011 = sampleAt(c011, size, sdfBias, v000);
    float v111 = sampleAt(c111, size, sdfBias, v000);

    float v00 = mix(v000, v100, offset.x);
    float v10 = mix(v010, v110, offset.x);
    float v01 = mix(v001, v101, offset.x);
    float v11 = mix(v011, v111, offset.x);

    float v0 = mix(v00, v10, offset.y);
    float v1 = mix(v01, v11, offset.y);

    return mix(v0, v1, offset.z);
}

bool intersectAABB(vec3 ro, vec3 rd, vec3 boxMin, vec3 boxMax, out float t_near, out float t_far) {
    vec3 invDir = 1.0 / rd;
    vec3 t0 = (boxMin - ro) * invDir;
    vec3 t1 = (boxMax - ro) * invDir;
    vec3 tsmaller = min(t0, t1);
    vec3 tbigger = max(t0, t1);
    t_near = max(max(tsmaller.x, tsmaller.y), tsmaller.z);
    t_far = min(min(tbigger.x, tbigger.y), tbigger.z);
    return t_far >= max(t_near, 0.0);
}

vec3 samplePointAt(ivec3 coord, ivec3 size, int bias) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, size)))
        return vec3(0.0);
    int idx = bias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    return vec3(
        cardPoint[idx * 9 + 0],
        cardPoint[idx * 9 + 1],
        cardPoint[idx * 9 + 2]
    );
}

vec3 sampleNormalAt(ivec3 coord, ivec3 size, int bias, vec3 bn) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, size)))
        return bn;
    int idx = bias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    return vec3(
        cardPoint[idx * 9 + 3],
        cardPoint[idx * 9 + 4],
        cardPoint[idx * 9 + 5]
    );
}

vec3 sampleNormal(vec3 p_card, ivec3 size, int bias) {
    ivec3 base = ivec3(floor(p_card));
    vec3 offset = p_card - (vec3(base) + vec3(0.5));

    int dx = int(sign(offset.x));
    int dy = int(sign(offset.y));
    int dz = int(sign(offset.z));
    offset = abs(offset);

    ivec3 c000 = base;
    ivec3 c100 = base + ivec3(dx, 0, 0);
    ivec3 c010 = base + ivec3(0, dy, 0);
    ivec3 c110 = base + ivec3(dx, dy, 0);
    ivec3 c001 = base + ivec3(0, 0, dz);
    ivec3 c101 = base + ivec3(dx, 0, dz);
    ivec3 c011 = base + ivec3(0, dy, dz);
    ivec3 c111 = base + ivec3(dx, dy, dz);

    vec3 n000 = sampleNormalAt(c000, size, bias, vec3(0.0));
    vec3 n100 = sampleNormalAt(c100, size, bias, n000);
    vec3 n010 = sampleNormalAt(c010, size, bias, n000);
    vec3 n110 = sampleNormalAt(c110, size, bias, n000);
    vec3 n001 = sampleNormalAt(c001, size, bias, n000);
    vec3 n101 = sampleNormalAt(c101, size, bias, n000);
    vec3 n011 = sampleNormalAt(c011, size, bias, n000);
    vec3 n111 = sampleNormalAt(c111, size, bias, n000);

    vec3 n00 = mix(n000, n100, offset.x);
    vec3 n10 = mix(n010, n110, offset.x);
    vec3 n01 = mix(n001, n101, offset.x);
    vec3 n11 = mix(n011, n111, offset.x);

    vec3 n0 = mix(n00, n10, offset.y);
    vec3 n1 = mix(n01, n11, offset.y);

    vec3 result = mix(n0, n1, offset.z);
    return normalize(result);
}

vec3 sampleTangentAt(ivec3 coord, ivec3 size, int bias) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, size)))
        return vec3(0.0, 0.0, 1.0);
    int idx = bias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    return vec3(
        cardPoint[idx * 9 + 6],
        cardPoint[idx * 9 + 7],
        cardPoint[idx * 9 + 8]
    );
}

vec3 getRadianceDirection(vec3 n_world, vec3 t_world, int ray_id, int subray_id, int num_subray, out float pdf) {
    int x = ray_id % 8;
    int y = ray_id / 8;
    int subray_per_side = int(sqrt(num_subray));
    int sub_x = subray_id % subray_per_side;
    int sub_y = subray_id / subray_per_side;

    float u1 = (float(x) + (float(sub_x) + 0.5) / float(subray_per_side)) / 8.0;
    float u2 = (float(y) + (float(sub_y) + 0.5) / float(subray_per_side)) / 8.0;

    float theta = acos(u1);           // polar angle
    float phi = 2.0 * PI * u2;        // azimuthal angle

    float sin_theta = sin(theta);
    float x_local = sin_theta * cos(phi);
    float y_local = sin_theta * sin(phi);
    float z_local = cos(theta);

    vec3 d_local = vec3(x_local, y_local, z_local);

    // Construct local basis
    vec3 B = normalize(cross(n_world, t_world));
    vec3 T = normalize(cross(B, n_world));

    vec3 d_world = normalize(T * d_local.x + B * d_local.y + n_world * d_local.z);
    pdf = 1.0 / (2.0 * PI); // Uniform over hemisphere
    return d_world;
}

int getRadianceId(vec3 n_world, vec3 t_world, out float pdf) {
    vec3 B = normalize(cross(n_world, t_world));
    vec3 T = normalize(cross(B, n_world));
    vec3 N = normalize(n_world);
    vec3 d_local = vec3(dot(d_world, T), dot(d_world, B), dot(d_world, N));
    float theta = acos(d_local.z);
    float phi = atan(d_local.y, d_local.x) + PI;
    float u1 = cos(theta);
    float u2 = phi / (2.0 * PI);
    int x = clamp(int(u1 * 8.0), 0, 7);
    int y = clamp(int(u2 * 8.0), 0, 7);
    int ray_id = y * 8 + x;
    pdf = 1.0 / (2.0 * PI);
    return ray_id;
}


vec3 sampleRadianceAt(int obj_idx, ivec3 coord, ivec3 size, int bias, vec3 p_world, vec3 d_world) {
    vec3 n_world = sampleNormal(coord, size, bias);
    vec3 t_world = sampleTangentAt(coord, size, bias);
    int idx = bias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    vec3 reflectance = vec3(
        cardSurface[obj_idx * 7 + 0],
        cardSurface[obj_idx * 7 + 1],
        cardSurface[obj_idx * 7 + 2]
    );
    float roughness = cardSurface[obj_idx * 7 + 3];
    vec3 emission = vec3(
        cardSurface[obj_idx * 7 + 4],
        cardSurface[obj_idx * 7 + 5],
        cardSurface[obj_idx * 7 + 6]
    );
    float threshold = 1.0 - roughness;
    threshold = clamp(threshold, 0.0, 1.0);
    vec3 radiance = vec3(0.0);
    for (int i = 0; i < 64; i++) {
        float pdf;
        vec3 radiance_v = getRadianceDirection(n_world, t_world, i, 1, 1, pdf);
        vec3 radiance_L = vec3(
            cardRadiance[idx * 64 * 3 + i * 3 + 0],
            cardRadiance[idx * 64 * 3 + i * 3 + 1],
            cardRadiance[idx * 64 * 3 + i * 3 + 2]
        );
        float abs_cos_theta = abs(dot(n_world, radiance_v));
        vec3 r = reflect(d_world, n_world);
        float cosine_similarity = max(dot(normalize(r), radiance_v), 0.01);
        if (cosine_similarity > threshold - 0.01) {
            radiance += reflectance * radiance_L * abs_cos_theta / pdf;
            // radiance += vec3(0.33) * radiance_L * abs_cos_theta / pdf;
        }
    }
    return (radiance / 64.0 / PI + emission);
}

vec3 getCardRadiance(vec3 p_world, vec3 d_world, int obj_idx) {
    int start = objCard[obj_idx * 2];
    int end = start + objCard[obj_idx * 2 + 1];
    for (int i = start; i < end; ++i) {
        ivec3 size = ivec3(
            cardSize[i * 4 + 0],
            cardSize[i * 4 + 1],
            cardSize[i * 4 + 2]
        );
        int cardBias = cardSize[i * 4 + 3];
        vec3 cardOrigin = vec3(
            cardCoord[i * 12 + 0],
            cardCoord[i * 12 + 1],
            cardCoord[i * 12 + 2]
        );
        mat3 cardTransform = mat3(
            vec3(cardCoord[i * 12 + 3], cardCoord[i * 12 + 4], cardCoord[i * 12 + 5]),
            vec3(cardCoord[i * 12 + 6], cardCoord[i * 12 + 7], cardCoord[i * 12 + 8]),
            vec3(cardCoord[i * 12 + 9], cardCoord[i * 12 +10], cardCoord[i * 12 +11])
        );
        vec3 p_card = cardTransform * (p_world - cardOrigin);
        ivec3 base = ivec3(floor(p_card));
        if (any(lessThan(base, ivec3(0))) || any(greaterThanEqual(base, size)))
            continue;
        return sampleRadianceAt(obj_idx, base, size, cardBias, p_world, d_world);
    }
    return vec3(1.0);
}

bool intersect(vec3 rayo, vec3 rayd, int obj_idx, out float t_hit, out vec3 radiance) {
    int sizeArrayBias = obj_idx * 4;
    int coordArrayBias = obj_idx * 12;
    
    ivec3 size = ivec3(
        sdfSize[sizeArrayBias + 0],
        sdfSize[sizeArrayBias + 1],
        sdfSize[sizeArrayBias + 2]
    );
    int sdfBias = sdfSize[sizeArrayBias + 3];
    vec3 sdfOrigin = vec3(
        sdfCoord[coordArrayBias + 0],
        sdfCoord[coordArrayBias + 1],
        sdfCoord[coordArrayBias + 2]
    );
    mat3 sdfTransform = mat3(
        vec3(sdfCoord[coordArrayBias + 3], sdfCoord[coordArrayBias + 4], sdfCoord[coordArrayBias + 5]),
        vec3(sdfCoord[coordArrayBias + 6], sdfCoord[coordArrayBias + 7], sdfCoord[coordArrayBias + 8]),
        vec3(sdfCoord[coordArrayBias + 9], sdfCoord[coordArrayBias +10], sdfCoord[coordArrayBias +11])
    );

    vec3 rayo_sdf = sdfTransform * (rayo - sdfOrigin);
    vec3 rayd_sdf = sdfTransform * rayd;

    // Intersect ray_sdf with the bounding box with min (0, 0, 0) and max vec3(size)
    float t_near, t_far;
    if (!intersectAABB(rayo_sdf, rayd_sdf, vec3(0.0), vec3(size), t_near, t_far))
        return false;

    // Ray marching in the sdf space
    float t = max(t_near, 0.0) + 0.0001;
    for (int i = 0; i < maxSteps && t < t_far; ++i) {
        vec3 p = rayo_sdf + t * rayd_sdf;
        float d = sampleSDF(p, size, sdfBias);
        if (abs(d) < epsilon) {
            t_hit = t;
            radiance = getCardRadiance(rayo + t * rayd, rayd, obj_idx);
            return true;
        }
        t += d;
        if (t > maxMarchDist) break;
    }

    // No hit
    t_hit = maxMarchDist;
    radiance = vec3(0.0);
    return false;
}

int randInt(inout int state, int range) {
    state = (state * 48271) % 2147483647; // classic LCG
    return state % range;
}

void main() {
    int pix = int(gl_GlobalInvocationID.x);
    vec3 p_world = vec3(
        cardPoint[pix * 9 + 0],
        cardPoint[pix * 9 + 1],
        cardPoint[pix * 9 + 2]
    );
    vec3 n_world = vec3(
        cardPoint[pix * 9 + 3],
        cardPoint[pix * 9 + 4],
        cardPoint[pix * 9 + 5]
    );
    vec3 t_world = vec3(
        cardPoint[pix * 9 + 6],
        cardPoint[pix * 9 + 7],
        cardPoint[pix * 9 + 8]
    );

    if (length(n_world) < 0.1) {
        cardRadiance[pix * 64 * 3 + 0] = 0.0;
        cardRadiance[pix * 64 * 3 + 1] = 0.0;
        cardRadiance[pix * 64 * 3 + 2] = 0.0;
        return;
    }

    int state = seed + pix;

    float radiance_buffer[64];
    int radiance_idx[64];
    for (int i = 0; i < 64; ++i) {
        radiance_buffer[i] = length(vec3(cardRadiance[pix * 64 * 3 + i * 3 + 0], 
                                         cardRadiance[pix * 64 * 3 + i * 3 + 1],
                                         cardRadiance[pix * 64 * 3 + i * 3 + 2]));
        radiance_idx[i] = i;
    }
    // Sort the radiance buffer, larger values first
    for (int i = 0; i < 64; ++i) {
        for (int j = i + 1; j < 64; ++j) {
            if (radiance_buffer[i] < radiance_buffer[j]) {
                float tmp = radiance_buffer[i];
                radiance_buffer[i] = radiance_buffer[j];
                radiance_buffer[j] = tmp;
                int tmp_idx = radiance_idx[i];
                radiance_idx[i] = radiance_idx[j];
                radiance_idx[j] = tmp_idx;
            }
        }
    }

    for (int ss = 0; ss < uNumSample; ++ss) {
        int i, num_subray;
        if (ss < uNumSample / 2) {
            i = radiance_idx[randInt(state, 16)];
            num_subray = 16;
        } else {
            i = radiance_idx[randInt(state, 48) + 16];
            num_subray = 4;
        }
        if (uNumSample == 64) {
            i = ss;
            num_subray = 16;
        }
        vec3 rayo;
        float pdf;
        vec3 tot_radiance = vec3(0.0);
        for (int j = 0; j < num_subray; j ++) {
            vec3 rayd = getRadianceDirection(n_world, t_world, i, j, num_subray, pdf);
            rayo = p_world + 0.25 * rayd;

            float mint = maxMarchDist;
            vec3 min_radiance = vec3(0.0);
            for (int n = 0; n < uNumObjects; ++n) {
                float t_hit;
                vec3 radiance;
                if (intersect(rayo, rayd, n, t_hit, radiance)) {
                    if (t_hit < mint) {
                        mint = t_hit;
                        min_radiance = radiance;
                    }
                }
            }
            if (mint < maxMarchDist) {
                tot_radiance += min_radiance;
            }
        }
        vec3 avg_radiance = tot_radiance / float(num_subray);

        cardRadiance[pix * 64 * 3 + i * 3 + 0] = avg_radiance.x;
        cardRadiance[pix * 64 * 3 + i * 3 + 1] = avg_radiance.y;
        cardRadiance[pix * 64 * 3 + i * 3 + 2] = avg_radiance.z;
    }
}
