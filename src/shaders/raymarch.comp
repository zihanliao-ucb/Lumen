#version 430

layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D screenImage;
layout(std430, binding = 1) buffer sdfSizeArray{ int sdfSize[]; };
layout(std430, binding = 2) buffer sdfCoordArray{ float sdfCoord[]; };
layout(std430, binding = 3) buffer sdfArray{ float sdf[]; };
layout(std430, binding = 4) buffer objCardArray{ int objCard[]; };
layout(std430, binding = 5) buffer cardSizeArray{ int cardSize[]; };
layout(std430, binding = 6) buffer cardCoordArray{ float cardCoord[]; };
layout(std430, binding = 7) buffer cardSurfaceArray{ float cardSurface[]; };
layout(std430, binding = 8) buffer cardPointArray{ float cardPoint[]; };
layout(std430, binding = 9) buffer cardRadianceArray{ float cardRadiance[]; };


uniform vec3 uCameraPos;
uniform mat3 uC2WMatrix; // camera to world matrix
uniform int uScreenW;
uniform int uScreenH;
uniform float uTanFovY;
uniform float uAspect;

uniform int uNumObjects;

uniform vec3 lightPosition;
uniform vec3 lightDirection;
uniform vec3 lightDimX;
uniform vec3 lightDimY;
uniform vec3 lightRadiance;
uniform float lightArea;
uniform int globalSeed;

const int maxSteps = 128;
const float epsilon = 0.005;
const float maxMarchDist = 10.0;
const float PI = 3.14159265359;
const int numRays = 16;


float sampleAt(ivec3 coord, ivec3 size, int sdfBias, float bv) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, size)))
        return bv;
    int index = sdfBias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    return sdf[index];
}

float sampleSDF(vec3 p_sdf, ivec3 size, int sdfBias) {
    ivec3 base = ivec3(floor(p_sdf));
    if (any(lessThan(base, ivec3(0))) || any(greaterThanEqual(base, size)))
        return maxMarchDist;

    vec3 offset = p_sdf - (vec3(base) + vec3(0.5));
    int dx = int(sign(offset.x));
    int dy = int(sign(offset.y));
    int dz = int(sign(offset.z));
    offset = abs(offset);

    ivec3 c000 = base;
    ivec3 c100 = base + ivec3(dx, 0, 0);
    ivec3 c010 = base + ivec3(0, dy, 0);
    ivec3 c110 = base + ivec3(dx, dy, 0);
    ivec3 c001 = base + ivec3(0, 0, dz);
    ivec3 c101 = base + ivec3(dx, 0, dz);
    ivec3 c011 = base + ivec3(0, dy, dz);
    ivec3 c111 = base + ivec3(dx, dy, dz);

    float v000 = sampleAt(c000, size, sdfBias, 0.0);
    float v100 = sampleAt(c100, size, sdfBias, v000);
    float v010 = sampleAt(c010, size, sdfBias, v000);
    float v110 = sampleAt(c110, size, sdfBias, v000);
    float v001 = sampleAt(c001, size, sdfBias, v000);
    float v101 = sampleAt(c101, size, sdfBias, v000);
    float v011 = sampleAt(c011, size, sdfBias, v000);
    float v111 = sampleAt(c111, size, sdfBias, v000);

    float v00 = mix(v000, v100, offset.x);
    float v10 = mix(v010, v110, offset.x);
    float v01 = mix(v001, v101, offset.x);
    float v11 = mix(v011, v111, offset.x);

    float v0 = mix(v00, v10, offset.y);
    float v1 = mix(v01, v11, offset.y);

    return mix(v0, v1, offset.z);
}

bool intersectAABB(vec3 ro, vec3 rd, vec3 boxMin, vec3 boxMax, out float t_near, out float t_far) {
    vec3 invDir = 1.0 / rd;
    vec3 t0 = (boxMin - ro) * invDir;
    vec3 t1 = (boxMax - ro) * invDir;
    vec3 tsmaller = min(t0, t1);
    vec3 tbigger = max(t0, t1);
    t_near = max(max(tsmaller.x, tsmaller.y), tsmaller.z);
    t_far = min(min(tbigger.x, tbigger.y), tbigger.z);
    return t_far >= max(t_near, 0.0);
}

vec3 samplePointAt(ivec3 coord, ivec3 size, int bias) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, size)))
        return vec3(0.0);
    int idx = bias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    return vec3(
        cardPoint[idx * 9 + 0],
        cardPoint[idx * 9 + 1],
        cardPoint[idx * 9 + 2]
    );
}

vec3 sampleNormalAt(ivec3 coord, ivec3 size, int bias, vec3 bn) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, size)))
        return bn;
    int idx = bias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    return vec3(
        cardPoint[idx * 9 + 3],
        cardPoint[idx * 9 + 4],
        cardPoint[idx * 9 + 5]
    );
}

vec3 sampleNormal(vec3 p_card, ivec3 size, int bias) {
    ivec3 base = ivec3(floor(p_card));
    vec3 offset = p_card - (vec3(base) + vec3(0.5));

    int dx = int(sign(offset.x));
    int dy = int(sign(offset.y));
    int dz = int(sign(offset.z));
    offset = abs(offset);

    ivec3 c000 = base;
    ivec3 c100 = base + ivec3(dx, 0, 0);
    ivec3 c010 = base + ivec3(0, dy, 0);
    ivec3 c110 = base + ivec3(dx, dy, 0);
    ivec3 c001 = base + ivec3(0, 0, dz);
    ivec3 c101 = base + ivec3(dx, 0, dz);
    ivec3 c011 = base + ivec3(0, dy, dz);
    ivec3 c111 = base + ivec3(dx, dy, dz);

    vec3 n000 = sampleNormalAt(c000, size, bias, vec3(0.0));
    vec3 n100 = sampleNormalAt(c100, size, bias, n000);
    vec3 n010 = sampleNormalAt(c010, size, bias, n000);
    vec3 n110 = sampleNormalAt(c110, size, bias, n000);
    vec3 n001 = sampleNormalAt(c001, size, bias, n000);
    vec3 n101 = sampleNormalAt(c101, size, bias, n000);
    vec3 n011 = sampleNormalAt(c011, size, bias, n000);
    vec3 n111 = sampleNormalAt(c111, size, bias, n000);

    vec3 n00 = mix(n000, n100, offset.x);
    vec3 n10 = mix(n010, n110, offset.x);
    vec3 n01 = mix(n001, n101, offset.x);
    vec3 n11 = mix(n011, n111, offset.x);

    vec3 n0 = mix(n00, n10, offset.y);
    vec3 n1 = mix(n01, n11, offset.y);

    vec3 result = mix(n0, n1, offset.z);
    return normalize(result);
}

vec3 sampleTangentAt(ivec3 coord, ivec3 size, int bias) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, size)))
        return vec3(0.0, 0.0, 1.0);
    int idx = bias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    return vec3(
        cardPoint[idx * 9 + 6],
        cardPoint[idx * 9 + 7],
        cardPoint[idx * 9 + 8]
    );
}

vec3 getRadianceDirection(vec3 n_world, vec3 t_world, int ray_id, int subray_id, int num_subray, out float pdf) {
    int x = ray_id % int(sqrt(numRays));
    int y = ray_id / int(sqrt(numRays));
    int subray_per_side = int(sqrt(num_subray));
    int sub_x = subray_id % subray_per_side;
    int sub_y = subray_id / subray_per_side;

    float u1 = (float(x) + (float(sub_x) + 0.5) / float(subray_per_side)) / sqrt(numRays);
    float u2 = (float(y) + (float(sub_y) + 0.5) / float(subray_per_side)) / sqrt(numRays);

    float theta = acos(u1);           // polar angle
    float phi = 2.0 * PI * u2;        // azimuthal angle

    float sin_theta = sin(theta);
    float x_local = sin_theta * cos(phi);
    float y_local = sin_theta * sin(phi);
    float z_local = cos(theta);

    vec3 d_local = vec3(x_local, y_local, z_local);

    // Construct local basis
    vec3 B = normalize(cross(n_world, t_world));
    vec3 T = normalize(cross(B, n_world));

    vec3 d_world = normalize(T * d_local.x + B * d_local.y + n_world * d_local.z);
    pdf = 1.0 / (2.0 * PI); // Uniform over hemisphere
    return d_world;
}

vec3 sampleRadianceAt(int obj_idx, ivec3 coord, ivec3 size, int bias, vec3 p_world, vec3 d_world) {
    if (any(lessThan(coord, ivec3(0))) || any(greaterThanEqual(coord, size)))
        return vec3(0.0);
    vec3 n_world = sampleNormal(coord, size, bias);
    vec3 t_world = sampleTangentAt(coord, size, bias);
    int idx = bias + coord.x + coord.y * size.x + coord.z * size.x * size.y;
    vec3 reflectance = vec3(
        cardSurface[obj_idx * 7 + 0],
        cardSurface[obj_idx * 7 + 1],
        cardSurface[obj_idx * 7 + 2]
    );
    float roughness = cardSurface[obj_idx * 7 + 3];
    float threshold = 1.0 - roughness;
    threshold = clamp(threshold, 0.0, 1.0);
    vec3 radiance = vec3(0.0);
    for (int i = 0; i < numRays; i++) {
        float pdf;
        vec3 radiance_v = getRadianceDirection(n_world, t_world, i, 1, 1, pdf);
        vec3 radiance_L = vec3(
            cardRadiance[idx * numRays * 3 + i * 3 + 0],
            cardRadiance[idx * numRays * 3 + i * 3 + 1],
            cardRadiance[idx * numRays * 3 + i * 3 + 2]
        );
        float abs_cos_theta = abs(dot(n_world, radiance_v));
        vec3 r = reflect(d_world, n_world);
        float cosine_similarity = max(dot(normalize(r), radiance_v), 0.01);
        // float cosine_similarity = dot(n_world, radiance_v);
        if (cosine_similarity > threshold) {
            radiance += reflectance * radiance_L * abs_cos_theta / pdf / roughness;
            // radiance += vec3(length(n_world)) * abs_cos_theta / pdf;
        }
    }
    return (radiance / float(numRays) / PI);
}

bool intersect(vec3 rayo, vec3 rayd, int obj_idx, out float t_hit) {
    int sizeArrayBias = obj_idx * 4;
    int coordArrayBias = obj_idx * 12;
    
    ivec3 size = ivec3(
        sdfSize[sizeArrayBias + 0],
        sdfSize[sizeArrayBias + 1],
        sdfSize[sizeArrayBias + 2]
    );
    int sdfBias = sdfSize[sizeArrayBias + 3];
    vec3 sdfOrigin = vec3(
        sdfCoord[coordArrayBias + 0],
        sdfCoord[coordArrayBias + 1],
        sdfCoord[coordArrayBias + 2]
    );
    mat3 sdfTransform = mat3(
        vec3(sdfCoord[coordArrayBias + 3], sdfCoord[coordArrayBias + 4], sdfCoord[coordArrayBias + 5]),
        vec3(sdfCoord[coordArrayBias + 6], sdfCoord[coordArrayBias + 7], sdfCoord[coordArrayBias + 8]),
        vec3(sdfCoord[coordArrayBias + 9], sdfCoord[coordArrayBias +10], sdfCoord[coordArrayBias +11])
    );
    vec3 emission = vec3(
        cardSurface[obj_idx * 7 + 4],
        cardSurface[obj_idx * 7 + 5],
        cardSurface[obj_idx * 7 + 6]
    );

    vec3 rayo_sdf = sdfTransform * (rayo - sdfOrigin);
    vec3 rayd_sdf = sdfTransform * rayd;

    // Intersect ray_sdf with the bounding box with min (0, 0, 0) and max vec3(size)
    float t_near, t_far;
    if (!intersectAABB(rayo_sdf, rayd_sdf, vec3(0.0), vec3(size), t_near, t_far))
        return false;

    // Ray marching in the sdf space
    float t = max(t_near, 0.01) + 0.0001;
    for (int i = 0; i < maxSteps && t < t_far; ++i) {
        vec3 p = rayo_sdf + t * rayd_sdf;
        float d = sampleSDF(p, size, sdfBias);
        if (abs(d) < epsilon) {
            t_hit = t;
            return true;
        }
        t += d;
        if (t > maxMarchDist) break;
    }

    // No hit
    t_hit = maxMarchDist;
    return false;
}

vec3 get_direct_light(int obj_idx, ivec3 coord, ivec3 size, int bias, vec3 p_world, vec3 d_world) {
    vec3 n_world = sampleNormal(coord, size, bias);
    if (length(n_world) < 0.1) return vec3(0.0);

    vec3 reflectance = vec3(
        cardSurface[obj_idx * 7 + 0],
        cardSurface[obj_idx * 7 + 1],
        cardSurface[obj_idx * 7 + 2]
    );
    float roughness = cardSurface[obj_idx * 7 + 3];

    vec3 radiance = vec3(0.0);
    const int ns_light_samples = 16;
    const int sqrt_ns = int(sqrt(float(ns_light_samples)));

    vec3 light_pos = lightPosition;
    vec3 light_dir = lightDirection;
    vec3 light_x = lightDimX;
    vec3 light_y = lightDimY;
    vec3 light_radiance = lightRadiance;
    float light_area = lightArea;

    for (int s = 0; s < ns_light_samples; ++s) {
        // Uniform sample in [-0.5, 0.5]
        int x = s % sqrt_ns;
        int y = s / sqrt_ns;
        vec2 u = (vec2(x, y) + vec2(0.5)) / float(sqrt_ns) - 0.5;
        vec3 target = light_pos + u.x * light_x + u.y * light_y;
        vec3 d = target - p_world;
        float dist2 = dot(d, d);
        float dist = sqrt(dist2);
        vec3 wi = d / dist;

        float cosTheta = dot(-wi, light_dir);
        if (cosTheta <= 0.0) continue;

        float pdf = dist2 / (light_area * cosTheta);
        float abs_cos_theta = max(dot(n_world, wi), 0.0);

        // Shadow ray test
        bool occluded = false;
        for (int obj = 0; obj < uNumObjects; ++obj) {
            float t_hit;
            if (obj == obj_idx) continue;
            if (intersect(p_world + 0.001 * wi, wi, obj, t_hit)) {
                if (t_hit < dist - 0.005) {
                    occluded = true;
                    break;
                }
            }
        }

        if (!occluded && pdf > 1e-6) {
            // BRDF: assume Lambertian here
            vec3 r = reflect(d_world, n_world);
            float cosine_similarity = max(dot(normalize(r), wi), 0.01);
            if (cosine_similarity < 1 - roughness) continue;
            vec3 brdf = reflectance / PI / roughness;
            radiance += brdf * light_radiance * abs_cos_theta / pdf;
        }
    }

    return radiance / float(ns_light_samples);
}

vec3 getCardRadiance(vec3 p_world, vec3 d_world, int obj_idx) {
    int start = objCard[obj_idx * 2];
    int end = start + objCard[obj_idx * 2 + 1];
    for (int i = start; i < end; ++i) {
        ivec3 size = ivec3(
            cardSize[i * 4 + 0],
            cardSize[i * 4 + 1],
            cardSize[i * 4 + 2]
        );
        int cardBias = cardSize[i * 4 + 3];
        vec3 cardOrigin = vec3(
            cardCoord[i * 12 + 0],
            cardCoord[i * 12 + 1],
            cardCoord[i * 12 + 2]
        );
        mat3 cardTransform = mat3(
            vec3(cardCoord[i * 12 + 3], cardCoord[i * 12 + 4], cardCoord[i * 12 + 5]),
            vec3(cardCoord[i * 12 + 6], cardCoord[i * 12 + 7], cardCoord[i * 12 + 8]),
            vec3(cardCoord[i * 12 + 9], cardCoord[i * 12 +10], cardCoord[i * 12 +11])
        );
        vec3 p_card = cardTransform * (p_world - cardOrigin);
        ivec3 base = ivec3(floor(p_card));
        if (any(lessThan(base, ivec3(0))) || any(greaterThanEqual(base, size)))
            continue;
        return sampleRadianceAt(obj_idx, base, size, cardBias, p_world, d_world) + get_direct_light(obj_idx, base, size, cardBias, p_world, d_world);
    }
    return vec3(0.0);
}

vec3 getDirectLight(vec3 p_world, vec3 d_world, int obj_idx) {
    int start = objCard[obj_idx * 2];
    int end = start + objCard[obj_idx * 2 + 1];
    for (int i = start; i < end; ++i) {
        ivec3 size = ivec3(
            cardSize[i * 4 + 0],
            cardSize[i * 4 + 1],
            cardSize[i * 4 + 2]
        );
        int cardBias = cardSize[i * 4 + 3];
        vec3 cardOrigin = vec3(
            cardCoord[i * 12 + 0],
            cardCoord[i * 12 + 1],
            cardCoord[i * 12 + 2]
        );
        mat3 cardTransform = mat3(
            vec3(cardCoord[i * 12 + 3], cardCoord[i * 12 + 4], cardCoord[i * 12 + 5]),
            vec3(cardCoord[i * 12 + 6], cardCoord[i * 12 + 7], cardCoord[i * 12 + 8]),
            vec3(cardCoord[i * 12 + 9], cardCoord[i * 12 +10], cardCoord[i * 12 +11])
        );
        vec3 p_card = cardTransform * (p_world - cardOrigin);
        ivec3 base = ivec3(floor(p_card));
        if (any(lessThan(base, ivec3(0))) || any(greaterThanEqual(base, size)))
            continue;
        return get_direct_light(obj_idx, base, size, cardBias, p_world, d_world);
    }
    return vec3(0.0);
}

uint lcg(inout uint state) {
    state = state * 1664525u + 1013904223u;
    return state;
}

float rand(inout uint state) {
    return float(lcg(state) % uint(100)) / 100.0; // 2^32
}

vec3 sampleHemisphereCosine(vec3 n, vec3 t, vec3 d_in, float roughness, inout uint seed, out float pdf) {
    // Perfect reflection direction
    vec3 r = normalize(reflect(-d_in, n));

    // Construct a local frame around r
    vec3 B = normalize(cross(r, abs(r.x) < 0.99 ? vec3(1, 0, 0) : vec3(0, 1, 0)));
    vec3 T = normalize(cross(B, r));

    // Cosine-weighted hemisphere sampling around reflection vector
    float u1 = rand(seed);
    float u2 = rand(seed);
    float r_disk = sqrt(u1);
    float phi = 2.0 * PI * u2;
    float x = r_disk * cos(phi);
    float y = r_disk * sin(phi);
    float z = sqrt(1.0 - u1);

    vec3 local_dir = vec3(x, y, z);
    vec3 sampled_dir = normalize(T * local_dir.x + B * local_dir.y + r * local_dir.z);

    // Apply roughness by slerping between perfect mirror and sampled direction
    sampled_dir = normalize(mix(r, sampled_dir, roughness));

    pdf = dot(sampled_dir, r) / PI;  // use cosine-weighted PDF w.r.t. perfect reflection direction
    return sampled_dir;
}


void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= uScreenW || pix.y >= uScreenH) return;

    vec3 totalRadiance = vec3(0.0);
    uint base_seed = uint(pix.y * uScreenW + pix.x);
    
    for (int s = 0; s < 16; ++s) {
        uint seed = base_seed + uint(s);
        lcg(seed); // Advance a few times to decorrelate
        lcg(seed);

        vec2 jitter = vec2(s % 4, s / 4) / 4.0 - 0.5;
        vec2 screenUV = (vec2(pix) + 0.5 + jitter) / vec2(uScreenW, uScreenH);
        vec2 ndc = screenUV * 2.0 - 1.0;

        vec3 rayDir = normalize(uC2WMatrix * vec3(ndc.x * uAspect * uTanFovY, ndc.y * uTanFovY, -1.0));
        vec3 rayOrigin = uCameraPos;

        vec3 throughput = vec3(1.0);
        vec3 radiance = vec3(0.0);

        for (int bounce = 0; bounce < 2; ++bounce) {
            float closestT = maxMarchDist;
            int hitObj = -1;

            for (int obj = 0; obj < uNumObjects; ++obj) {
                float t_hit;
                if (intersect(rayOrigin, rayDir, obj, t_hit)) {
                    if (t_hit < closestT) {
                        closestT = t_hit;
                        hitObj = obj;
                    }
                }
            }

            if (hitObj == -1) break;

            vec3 hitPoint = rayOrigin + closestT * rayDir;

            if (bounce < 1) {
                radiance += throughput * getDirectLight(hitPoint, rayDir, hitObj);
                vec3 emission = vec3(
                    cardSurface[hitObj * 7 + 4],
                    cardSurface[hitObj * 7 + 5],
                    cardSurface[hitObj * 7 + 6]
                );
                radiance += emission;
            } else {
                // radiance += throughput * getCardRadiance(hitPoint, rayDir, hitObj);
                radiance += throughput * getDirectLight(hitPoint, rayDir, hitObj);
                break;
            }

            // Sample cosine-weighted hemisphere
            int start = objCard[hitObj * 2];
            int end = start + objCard[hitObj * 2 + 1];
            bool found = false;

            for (int i = start; i < end; ++i) {
                ivec3 size = ivec3(cardSize[i * 4 + 0], cardSize[i * 4 + 1], cardSize[i * 4 + 2]);
                int cardBias = cardSize[i * 4 + 3];
                vec3 origin = vec3(cardCoord[i * 12 + 0], cardCoord[i * 12 + 1], cardCoord[i * 12 + 2]);
                mat3 transform = mat3(
                    vec3(cardCoord[i * 12 + 3], cardCoord[i * 12 + 4], cardCoord[i * 12 + 5]),
                    vec3(cardCoord[i * 12 + 6], cardCoord[i * 12 + 7], cardCoord[i * 12 + 8]),
                    vec3(cardCoord[i * 12 + 9], cardCoord[i * 12 +10], cardCoord[i * 12 +11])
                );
                vec3 p_card = transform * (hitPoint - origin);
                ivec3 base = ivec3(floor(p_card));
                if (all(greaterThanEqual(base, ivec3(0))) && all(lessThan(base, size))) {
                    vec3 n_world = sampleNormal(base, size, cardBias);
                    if (length(n_world) < 0.1) break;

                    vec3 t_world = sampleTangentAt(base, size, cardBias);
                    float roughness = cardSurface[hitObj * 7 + 3];
                    float pdf;
                    vec3 newDir = sampleHemisphereCosine(n_world, t_world, rayDir, roughness, seed, pdf);

                    vec3 brdf = vec3(
                        cardSurface[hitObj * 7 + 0],
                        cardSurface[hitObj * 7 + 1],
                        cardSurface[hitObj * 7 + 2]
                    ) / PI;

                    float cosTheta = max(dot(n_world, newDir), 0.0);
                    throughput *= brdf * cosTheta / pdf;

                    rayOrigin = hitPoint + 0.02 * newDir;
                    rayDir = newDir;
                    found = true;
                    break;
                }
            }

            if (!found) break;
        }

        totalRadiance += radiance;
    }

    vec3 avgRadiance = totalRadiance / 16.0;
    imageStore(screenImage, pix, vec4(avgRadiance, 1.0));
}

